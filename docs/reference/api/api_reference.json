{
  "title": "FQCN Converter API Reference",
  "description": "Complete API reference for the Ansible FQCN Converter library",
  "version": "0.1.0",
  "classes": {
    "FQCNConverter": {
      "name": "FQCNConverter",
      "description": "Core conversion engine",
      "docstring": "Main FQCN conversion engine with configurable mappings and robust error handling.\n\nThe FQCNConverter class provides the core functionality for converting Ansible\nplaybooks and task files from short module names to Fully Qualified Collection\nNames (FQCNs). It supports custom configuration, backup creation, and comprehensive\nerror handling.\n\nFeatures:\n    - Intelligent module detection and conversion\n    - Configurable FQCN mappings\n    - Backup file creation for safety\n    - Dry-run mode for previewing changes\n    - Comprehensive error reporting\n    - Support for various Ansible file formats\n\nExample:\n    >>> converter = FQCNConverter()\n    >>> result = converter.convert_file(\"playbook.yml\")\n    >>> if result.success:\n    ...     print(f\"Successfully converted {result.changes_made} modules\")\n    \n    >>> # Using custom mappings\n    >>> custom_mappings = {\"my_module\": \"my.collection.my_module\"}\n    >>> converter = FQCNConverter(custom_mappings=custom_mappings)\n    \n    >>> # Dry run to preview changes\n    >>> result = converter.convert_file(\"playbook.yml\", dry_run=True)\n    >>> print(f\"Would convert {result.changes_made} modules\")",
      "module": "fqcn_converter.core.converter",
      "methods": {
        "__init__": {
          "signature": "(self, config_path: Union[str, pathlib._local.Path, NoneType] = None, custom_mappings: Optional[Dict[str, str]] = None, create_backups: bool = True, backup_suffix: str = '.fqcn_backup') -> None",
          "docstring": "Initialize converter with configuration and settings.\n\nThe converter loads default FQCN mappings and optionally merges them with\ncustom configuration and mappings. It supports various configuration sources\nand provides fallback mechanisms for robust operation.\n\nArgs:\n    config_path: Path to custom configuration file (YAML format).\n                If provided, mappings from this file will be merged with defaults.\n    custom_mappings: Dictionary of custom module mappings in the format\n                   {\"short_name\": \"namespace.collection.module_name\"}.\n                   These take precedence over config file mappings.\n    create_backups: Whether to create backup files before conversion.\n                  Defaults to True for safety.\n    backup_suffix: Suffix to append to backup files. Defaults to \".fqcn_backup\".\n    \nRaises:\n    ConfigurationError: If configuration loading fails or contains invalid data.\n                      The converter will attempt to use default mappings as fallback.\n\nExample:\n    >>> # Basic initialization with defaults\n    >>> converter = FQCNConverter()\n    \n    >>> # With custom configuration file\n    >>> converter = FQCNConverter(config_path=\"my_config.yml\")\n    \n    >>> # With custom mappings\n    >>> mappings = {\"my_module\": \"my.collection.my_module\"}\n    >>> converter = FQCNConverter(custom_mappings=mappings)\n    \n    >>> # Disable backups for testing\n    >>> converter = FQCNConverter(create_backups=False)",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "config_path": {
              "type": "typing.Union[str, pathlib._local.Path, NoneType]",
              "default": "None",
              "description": "Path to custom configuration file (YAML format)."
            },
            "custom_mappings": {
              "type": "typing.Optional[typing.Dict[str, str]]",
              "default": "None",
              "description": "Dictionary of custom module mappings in the format"
            },
            "create_backups": {
              "type": "<class 'bool'>",
              "default": "True",
              "description": "Whether to create backup files before conversion."
            },
            "backup_suffix": {
              "type": "<class 'str'>",
              "default": ".fqcn_backup",
              "description": "Suffix to append to backup files. Defaults to \".fqcn_backup\"."
            }
          },
          "returns": {
            "type": "None",
            "description": ""
          },
          "raises": [
            {
              "exception": "ConfigurationError",
              "description": "If configuration loading fails or contains invalid data."
            }
          ]
        },
        "convert_content": {
          "signature": "(self, content: str, file_type: str = 'yaml') -> fqcn_converter.core.converter.ConversionResult",
          "docstring": "Convert Ansible content string to FQCN format.\n\nArgs:\n    content: The content to convert\n    file_type: Type of content ('yaml' supported)\n    \nReturns:\n    ConversionResult with conversion details",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "content": {
              "type": "<class 'str'>",
              "default": null,
              "description": "The content to convert"
            },
            "file_type": {
              "type": "<class 'str'>",
              "default": "yaml",
              "description": "Type of content ('yaml' supported)"
            }
          },
          "returns": {
            "type": "<class 'fqcn_converter.core.converter.ConversionResult'>",
            "description": "ConversionResult with conversion details"
          },
          "raises": []
        },
        "convert_file": {
          "signature": "(self, file_path: Union[str, pathlib._local.Path], dry_run: bool = False) -> fqcn_converter.core.converter.ConversionResult",
          "docstring": "Convert a single Ansible file to FQCN format.\n\nArgs:\n    file_path: Path to the Ansible file to convert\n    dry_run: If True, perform conversion without writing changes\n    \nReturns:\n    ConversionResult with conversion details\n    \nRaises:\n    FileAccessError: If file cannot be read or written\n    ConversionError: If conversion fails",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "file_path": {
              "type": "typing.Union[str, pathlib._local.Path]",
              "default": null,
              "description": "Path to the Ansible file to convert"
            },
            "dry_run": {
              "type": "<class 'bool'>",
              "default": "False",
              "description": "If True, perform conversion without writing changes"
            }
          },
          "returns": {
            "type": "<class 'fqcn_converter.core.converter.ConversionResult'>",
            "description": "ConversionResult with conversion details"
          },
          "raises": [
            {
              "exception": "FileAccessError",
              "description": "If file cannot be read or written"
            },
            {
              "exception": "ConversionError",
              "description": "If conversion fails"
            }
          ]
        }
      },
      "properties": {},
      "class_attributes": {}
    },
    "ValidationEngine": {
      "name": "ValidationEngine",
      "description": "Validation and compliance checking",
      "docstring": "Handles validation of FQCN conversions with comprehensive validation logic.\n\nThe ValidationEngine analyzes Ansible files to ensure proper FQCN usage,\nidentifies conversion issues, and provides detailed compliance scoring.\nIt supports various validation modes and provides actionable feedback.\n\nFeatures:\n    - Comprehensive FQCN compliance checking\n    - Detailed issue reporting with line numbers\n    - Compliance scoring (0.0 to 1.0)\n    - Support for multiple Ansible file formats\n    - Configurable validation strictness\n    - Performance metrics and timing\n\nExample:\n    >>> validator = ValidationEngine()\n    >>> result = validator.validate_file(\"playbook.yml\")\n    >>> \n    >>> if result.valid:\n    ...     print(f\"\u2705 File is compliant (score: {result.score:.1%})\")\n    ... else:\n    ...     print(f\"\u274c Found {len(result.issues)} issues\")\n    ...     for issue in result.issues:\n    ...         print(f\"  Line {issue.line_number}: {issue.message}\")\n    \n    >>> # Validate content directly\n    >>> yaml_content = \"- copy: {src: file, dest: /tmp/file}\"\n    >>> result = validator.validate_content(yaml_content)",
      "module": "fqcn_converter.core.validator",
      "methods": {
        "__init__": {
          "signature": "(self) -> None",
          "docstring": "Initialize validation engine.",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            }
          },
          "returns": {
            "type": "None",
            "description": ""
          },
          "raises": []
        },
        "validate_content": {
          "signature": "(self, content: str, file_path: str = '<content>') -> fqcn_converter.core.validator.ValidationResult",
          "docstring": "Validate content string for FQCN compliance.\n\nArgs:\n    content: The content to validate\n    file_path: Optional file path for reporting\n    \nReturns:\n    ValidationResult with validation details",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "content": {
              "type": "<class 'str'>",
              "default": null,
              "description": "The content to validate"
            },
            "file_path": {
              "type": "<class 'str'>",
              "default": "<content>",
              "description": "Optional file path for reporting"
            }
          },
          "returns": {
            "type": "<class 'fqcn_converter.core.validator.ValidationResult'>",
            "description": "ValidationResult with validation details"
          },
          "raises": []
        },
        "validate_conversion": {
          "signature": "(self, file_path: Union[str, pathlib._local.Path]) -> fqcn_converter.core.validator.ValidationResult",
          "docstring": "Validate that a file has been properly converted.\n\nArgs:\n    file_path: Path to the file to validate\n    \nReturns:\n    ValidationResult with validation details\n    \nRaises:\n    FileAccessError: If file cannot be read\n    ValidationError: If validation process fails",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "file_path": {
              "type": "typing.Union[str, pathlib._local.Path]",
              "default": null,
              "description": "Path to the file to validate"
            }
          },
          "returns": {
            "type": "<class 'fqcn_converter.core.validator.ValidationResult'>",
            "description": "ValidationResult with validation details"
          },
          "raises": [
            {
              "exception": "FileAccessError",
              "description": "If file cannot be read"
            },
            {
              "exception": "ValidationError",
              "description": "If validation process fails"
            }
          ]
        }
      },
      "properties": {},
      "class_attributes": {}
    },
    "BatchProcessor": {
      "name": "BatchProcessor",
      "description": "Batch processing operations",
      "docstring": "Handles batch conversion of multiple Ansible projects with parallel processing.\n\nThe BatchProcessor provides efficient processing of multiple Ansible projects\nusing parallel workers, comprehensive error handling, and detailed reporting.\nIt automatically discovers projects and handles failures gracefully.\n\nFeatures:\n    - Parallel processing with configurable worker count\n    - Automatic project discovery\n    - Comprehensive error handling and recovery\n    - Detailed progress reporting\n    - Performance metrics and timing\n    - Graceful handling of individual project failures\n\nExample:\n    >>> processor = BatchProcessor(max_workers=4)\n    >>> projects = processor.discover_projects(\"/path/to/ansible/repos\")\n    >>> result = processor.process_projects(projects)\n    >>> \n    >>> print(f\"Processed {result.total_projects} projects\")\n    >>> print(f\"Success rate: {result.success_rate:.1%}\")\n    >>> \n    >>> # With progress callback\n    >>> def progress_callback(completed, total, current):\n    ...     print(f\"Progress: {completed}/{total} - {current}\")\n    >>> \n    >>> processor = BatchProcessor(\n    ...     max_workers=4,\n    ...     progress_callback=progress_callback\n    ... )",
      "module": "fqcn_converter.core.batch",
      "methods": {
        "__init__": {
          "signature": "(self, max_workers: int = 4, config_path: Union[str, pathlib._local.Path, NoneType] = None, progress_callback: Optional[<built-in function callable>] = None) -> None",
          "docstring": "Initialize batch processor with worker configuration.\n\nArgs:\n    max_workers: Maximum number of parallel workers to use.\n                Defaults to 4. Set to 1 for sequential processing.\n    config_path: Optional path to configuration file for conversions.\n    progress_callback: Optional callback function for progress updates.\n                     Called with (completed_count, total_count, current_project).\n\nExample:\n    >>> # Basic initialization\n    >>> processor = BatchProcessor()\n    \n    >>> # With custom worker count\n    >>> processor = BatchProcessor(max_workers=8)\n    \n    >>> # With progress tracking\n    >>> def track_progress(done, total, current):\n    ...     print(f\"{done}/{total}: {current}\")\n    >>> processor = BatchProcessor(progress_callback=track_progress)",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "max_workers": {
              "type": "<class 'int'>",
              "default": "4",
              "description": "Maximum number of parallel workers to use."
            },
            "config_path": {
              "type": "typing.Union[str, pathlib._local.Path, NoneType]",
              "default": "None",
              "description": "Optional path to configuration file for conversions."
            },
            "progress_callback": {
              "type": "typing.Optional[<built-in function callable>]",
              "default": "None",
              "description": "Optional callback function for progress updates."
            }
          },
          "returns": {
            "type": "None",
            "description": ""
          },
          "raises": []
        },
        "discover_projects": {
          "signature": "(self, root_dir: Union[str, pathlib._local.Path], project_patterns: Optional[List[str]] = None, exclude_patterns: Optional[List[str]] = None) -> List[str]",
          "docstring": "Discover Ansible projects in directory tree.\n\nRecursively searches for Ansible projects based on common indicators\nsuch as playbook files, inventory files, and directory structure.\n\nArgs:\n    root_dir: Root directory to search for projects\n    project_patterns: Optional list of patterns to identify projects.\n                    Defaults to common Ansible project indicators.\n    exclude_patterns: Optional list of patterns to exclude directories.\n                    Defaults to common non-project directories.\n\nReturns:\n    List of discovered project directory paths\n\nExample:\n    >>> processor = BatchProcessor()\n    >>> projects = processor.discover_projects(\"/path/to/repos\")\n    >>> print(f\"Found {len(projects)} Ansible projects\")\n    \n    >>> # With custom patterns\n    >>> projects = processor.discover_projects(\n    ...     \"/path/to/repos\",\n    ...     project_patterns=[\"**/playbooks\", \"**/roles\"],\n    ...     exclude_patterns=[\"**/archive/**\", \"**/.git/**\"]\n    ... )",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "root_dir": {
              "type": "typing.Union[str, pathlib._local.Path]",
              "default": null,
              "description": "Root directory to search for projects"
            },
            "project_patterns": {
              "type": "typing.Optional[typing.List[str]]",
              "default": "None",
              "description": "Optional list of patterns to identify projects."
            },
            "exclude_patterns": {
              "type": "typing.Optional[typing.List[str]]",
              "default": "None",
              "description": "Optional list of patterns to exclude directories."
            }
          },
          "returns": {
            "type": "typing.List[str]",
            "description": "List of discovered project directory paths"
          },
          "raises": []
        },
        "process_projects": {
          "signature": "(self, projects: List[str], dry_run: bool = False, continue_on_error: bool = True) -> fqcn_converter.core.batch.BatchResult",
          "docstring": "Process multiple projects with parallel execution.\n\nConverts multiple Ansible projects using parallel workers with\ncomprehensive error handling and detailed reporting.\n\nArgs:\n    projects: List of project directory paths to process\n    dry_run: If True, perform conversion preview without making changes\n    continue_on_error: If True, continue processing other projects\n                     when individual projects fail\n\nReturns:\n    BatchResult containing processing statistics and individual results\n\nRaises:\n    BatchProcessingError: If batch processing fails critically\n\nExample:\n    >>> processor = BatchProcessor(max_workers=4)\n    >>> projects = [\"/path/to/project1\", \"/path/to/project2\"]\n    >>> \n    >>> # Dry run to preview changes\n    >>> result = processor.process_projects(projects, dry_run=True)\n    >>> print(f\"Would convert {result.total_modules_converted} modules\")\n    >>> \n    >>> # Actual processing\n    >>> result = processor.process_projects(projects)\n    >>> if result.success_rate > 0.8:\n    ...     print(\"Batch processing successful!\")",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "projects": {
              "type": "typing.List[str]",
              "default": null,
              "description": "List of project directory paths to process"
            },
            "dry_run": {
              "type": "<class 'bool'>",
              "default": "False",
              "description": "If True, perform conversion preview without making changes"
            },
            "continue_on_error": {
              "type": "<class 'bool'>",
              "default": "True",
              "description": "If True, continue processing other projects"
            }
          },
          "returns": {
            "type": "<class 'fqcn_converter.core.batch.BatchResult'>",
            "description": "BatchResult containing processing statistics and individual results"
          },
          "raises": [
            {
              "exception": "BatchProcessingError",
              "description": "If batch processing fails critically"
            }
          ]
        }
      },
      "properties": {},
      "class_attributes": {}
    },
    "ConfigurationManager": {
      "name": "ConfigurationManager",
      "description": "Configuration management",
      "docstring": "Manages FQCN mappings and converter settings.",
      "module": "fqcn_converter.config.manager",
      "methods": {
        "__init__": {
          "signature": "(self) -> None",
          "docstring": "Initialize configuration manager.",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            }
          },
          "returns": {
            "type": "None",
            "description": ""
          },
          "raises": []
        },
        "load_custom_mappings": {
          "signature": "(self, config_path: Union[str, pathlib._local.Path]) -> Dict[str, str]",
          "docstring": "Load custom mappings from user-provided file.\n\nArgs:\n    config_path: Path to custom configuration file\n    \nReturns:\n    Dictionary mapping short module names to FQCNs\n    \nRaises:\n    ConfigurationError: If custom configuration cannot be loaded",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "config_path": {
              "type": "typing.Union[str, pathlib._local.Path]",
              "default": null,
              "description": "Path to custom configuration file"
            }
          },
          "returns": {
            "type": "typing.Dict[str, str]",
            "description": "Dictionary mapping short module names to FQCNs"
          },
          "raises": [
            {
              "exception": "ConfigurationError",
              "description": "If custom configuration cannot be loaded"
            }
          ]
        },
        "load_default_mappings": {
          "signature": "(self) -> Dict[str, str]",
          "docstring": "Load default FQCN mappings from bundled configuration.\n\nReturns:\n    Dictionary mapping short module names to FQCNs\n    \nRaises:\n    ConfigurationError: If default configuration cannot be loaded",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            }
          },
          "returns": {
            "type": "typing.Dict[str, str]",
            "description": "Dictionary mapping short module names to FQCNs"
          },
          "raises": [
            {
              "exception": "ConfigurationError",
              "description": "If default configuration cannot be loaded"
            }
          ]
        },
        "load_settings": {
          "signature": "(self, config_path: Union[str, pathlib._local.Path, NoneType] = None) -> fqcn_converter.config.manager.ConversionSettings",
          "docstring": "Load conversion settings from configuration.\n\nArgs:\n    config_path: Optional path to custom configuration file\n    \nReturns:\n    ConversionSettings object with loaded settings",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "config_path": {
              "type": "typing.Union[str, pathlib._local.Path, NoneType]",
              "default": "None",
              "description": "Optional path to custom configuration file"
            }
          },
          "returns": {
            "type": "<class 'fqcn_converter.config.manager.ConversionSettings'>",
            "description": "ConversionSettings object with loaded settings"
          },
          "raises": []
        },
        "merge_mappings": {
          "signature": "(self, *mapping_dicts: Dict[str, str]) -> Dict[str, str]",
          "docstring": "Merge multiple mapping dictionaries with precedence rules.\n\nArgs:\n    *mapping_dicts: Variable number of mapping dictionaries\n    \nReturns:\n    Merged dictionary with later dictionaries taking precedence\n    \nNote:\n    Later dictionaries in the argument list take precedence over earlier ones.\n    This allows for: base_mappings -> custom_mappings -> user_overrides",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "mapping_dicts": {
              "type": "typing.Dict[str, str]",
              "default": null,
              "description": ""
            }
          },
          "returns": {
            "type": "typing.Dict[str, str]",
            "description": "Merged dictionary with later dictionaries taking precedence Note: Later dictionaries in the argument list take precedence over earlier ones. This allows for: base_mappings -> custom_mappings -> user_overrides"
          },
          "raises": []
        },
        "validate_configuration": {
          "signature": "(self, config_data: Dict[str, Any]) -> bool",
          "docstring": "Validate configuration data against schema.\n\nArgs:\n    config_data: Configuration data to validate\n    \nReturns:\n    True if valid, False otherwise",
          "parameters": {
            "self": {
              "type": "Any",
              "default": null,
              "description": ""
            },
            "config_data": {
              "type": "typing.Dict[str, typing.Any]",
              "default": null,
              "description": "Configuration data to validate"
            }
          },
          "returns": {
            "type": "<class 'bool'>",
            "description": "True if valid, False otherwise"
          },
          "raises": []
        }
      },
      "properties": {},
      "class_attributes": {}
    }
  },
  "dataclasses": {
    "ConversionResult": {
      "name": "ConversionResult",
      "description": "Conversion operation results",
      "docstring": "Result of a single file conversion operation.\n\nThis class encapsulates all information about a conversion operation,\nincluding success status, changes made, and any errors or warnings\nencountered during the process.\n\nAttributes:\n    success: Whether the conversion operation completed successfully\n    file_path: Path to the file that was converted (or attempted)\n    changes_made: Number of module conversions performed\n    errors: List of error messages encountered during conversion\n    warnings: List of warning messages from the conversion process\n    original_content: Original file content before conversion (optional)\n    converted_content: File content after conversion (optional)\n    processing_time: Time taken for the conversion operation in seconds\n    backup_path: Path to backup file if one was created (optional)\n\nExample:\n    >>> result = converter.convert_file(\"playbook.yml\")\n    >>> if result.success:\n    ...     print(f\"Converted {result.changes_made} modules\")\n    ... else:\n    ...     print(f\"Conversion failed: {result.errors}\")",
      "module": "fqcn_converter.core.converter",
      "fields": {
        "success": {
          "type": "<class 'bool'>",
          "description": "Whether the conversion operation completed successfully"
        },
        "file_path": {
          "type": "<class 'str'>",
          "description": "Path to the file that was converted (or attempted)"
        },
        "changes_made": {
          "type": "<class 'int'>",
          "description": "Number of module conversions performed"
        },
        "errors": {
          "type": "typing.List[str]",
          "description": "List of error messages encountered during conversion"
        },
        "warnings": {
          "type": "typing.List[str]",
          "description": "List of warning messages from the conversion process"
        },
        "original_content": {
          "type": "typing.Optional[str]",
          "description": "Original file content before conversion (optional)"
        },
        "converted_content": {
          "type": "typing.Optional[str]",
          "description": "File content after conversion (optional)"
        },
        "processing_time": {
          "type": "<class 'float'>",
          "description": "Time taken for the conversion operation in seconds"
        },
        "backup_path": {
          "type": "typing.Optional[str]",
          "description": "Path to backup file if one was created (optional)"
        }
      },
      "is_dataclass": true
    },
    "ValidationResult": {
      "name": "ValidationResult",
      "description": "Validation operation results",
      "docstring": "Result of validation operation.\n\nThis class contains comprehensive information about the validation of an\nAnsible file, including compliance score, issues found, and statistics.\n\nAttributes:\n    valid: Whether the file passes validation (no critical errors)\n    file_path: Path to the validated file\n    issues: List of validation issues found in the file\n    score: FQCN completeness score from 0.0 (no compliance) to 1.0 (fully compliant)\n    total_modules: Total number of modules found in the file\n    fqcn_modules: Number of modules already using FQCN format\n    short_modules: Number of modules using short names\n    processing_time: Time taken for validation in seconds\n\nExample:\n    >>> result = validator.validate_file(\"playbook.yml\")\n    >>> print(f\"Validation score: {result.score:.1%}\")\n    >>> if not result.valid:\n    ...     for issue in result.issues:\n    ...         print(f\"Line {issue.line_number}: {issue.message}\")",
      "module": "fqcn_converter.core.validator",
      "fields": {
        "valid": {
          "type": "<class 'bool'>",
          "description": "Whether the file passes validation (no critical errors)"
        },
        "file_path": {
          "type": "<class 'str'>",
          "description": "Path to the validated file"
        },
        "issues": {
          "type": "typing.List[fqcn_converter.core.validator.ValidationIssue]",
          "description": "List of validation issues found in the file"
        },
        "score": {
          "type": "<class 'float'>",
          "description": "FQCN completeness score from 0.0 (no compliance) to 1.0 (fully compliant)"
        },
        "total_modules": {
          "type": "<class 'int'>",
          "description": "Total number of modules found in the file"
        },
        "fqcn_modules": {
          "type": "<class 'int'>",
          "description": "Number of modules already using FQCN format"
        },
        "short_modules": {
          "type": "<class 'int'>",
          "description": "Number of modules using short names"
        },
        "processing_time": {
          "type": "<class 'float'>",
          "description": "Time taken for validation in seconds"
        }
      },
      "is_dataclass": true
    },
    "ValidationIssue": {
      "name": "ValidationIssue",
      "description": "Individual validation issues",
      "docstring": "Represents a validation issue found in a file.\n\nThis class encapsulates information about a specific validation problem,\nincluding its location, severity, and suggested remediation.\n\nAttributes:\n    line_number: Line number where the issue occurs (1-based)\n    column: Column number where the issue occurs (1-based)\n    severity: Severity level of the issue ('error', 'warning', 'info')\n    message: Human-readable description of the issue\n    suggestion: Suggested fix or remediation for the issue\n    module_name: Name of the module related to this issue (optional)\n    expected_fqcn: Expected FQCN for the module (optional)\n\nExample:\n    >>> issue = ValidationIssue(\n    ...     line_number=15,\n    ...     column=5,\n    ...     severity='error',\n    ...     message=\"Short module name 'copy' should use FQCN\",\n    ...     suggestion=\"Replace 'copy' with 'ansible.builtin.copy'\"\n    ... )",
      "module": "fqcn_converter.core.validator",
      "fields": {
        "line_number": {
          "type": "<class 'int'>",
          "description": "Line number where the issue occurs (1-based)"
        },
        "column": {
          "type": "<class 'int'>",
          "description": "Column number where the issue occurs (1-based)"
        },
        "severity": {
          "type": "<class 'str'>",
          "description": "Severity level of the issue ('error', 'warning', 'info')"
        },
        "message": {
          "type": "<class 'str'>",
          "description": "Human-readable description of the issue"
        },
        "suggestion": {
          "type": "<class 'str'>",
          "description": "Suggested fix or remediation for the issue"
        },
        "module_name": {
          "type": "<class 'str'>",
          "description": "Name of the module related to this issue (optional)"
        },
        "expected_fqcn": {
          "type": "<class 'str'>",
          "description": "Expected FQCN for the module (optional)"
        }
      },
      "is_dataclass": true
    },
    "BatchResult": {
      "name": "BatchResult",
      "description": "Batch processing results",
      "docstring": "Result of batch processing operation.\n\nThis class encapsulates the results of processing multiple Ansible projects\nin a batch operation, including success/failure statistics, individual results,\nand performance metrics.\n\nAttributes:\n    total_projects: Total number of projects processed\n    successful_conversions: Number of projects converted successfully\n    failed_conversions: Number of projects that failed conversion\n    project_results: List of individual ConversionResult objects for each project\n    execution_time: Total time taken for batch processing in seconds\n    summary_report: Human-readable summary of the batch operation\n    total_files_processed: Total number of files processed across all projects\n    total_modules_converted: Total number of modules converted across all projects\n    success_rate: Success rate as a percentage (0.0 to 1.0)\n    average_processing_time: Average processing time per project in seconds\n\nExample:\n    >>> result = processor.process_projects(project_paths)\n    >>> print(f\"Processed {result.total_projects} projects\")\n    >>> print(f\"Success rate: {result.success_rate:.1%}\")\n    >>> print(f\"Total modules converted: {result.total_modules_converted}\")",
      "module": "fqcn_converter.core.batch",
      "fields": {
        "total_projects": {
          "type": "<class 'int'>",
          "description": "Total number of projects processed"
        },
        "successful_conversions": {
          "type": "<class 'int'>",
          "description": "Number of projects converted successfully"
        },
        "failed_conversions": {
          "type": "<class 'int'>",
          "description": "Number of projects that failed conversion"
        },
        "project_results": {
          "type": "typing.List[fqcn_converter.core.converter.ConversionResult]",
          "description": "List of individual ConversionResult objects for each project"
        },
        "execution_time": {
          "type": "<class 'float'>",
          "description": "Total time taken for batch processing in seconds"
        },
        "summary_report": {
          "type": "<class 'str'>",
          "description": "Human-readable summary of the batch operation"
        },
        "total_files_processed": {
          "type": "<class 'int'>",
          "description": "Total number of files processed across all projects"
        },
        "total_modules_converted": {
          "type": "<class 'int'>",
          "description": "Total number of modules converted across all projects"
        },
        "success_rate": {
          "type": "<class 'float'>",
          "description": "Success rate as a percentage (0.0 to 1.0)"
        },
        "average_processing_time": {
          "type": "<class 'float'>",
          "description": "Average processing time per project in seconds"
        }
      },
      "is_dataclass": true
    }
  },
  "examples": [
    {
      "title": "Basic Conversion",
      "description": "Convert a single Ansible file to FQCN format",
      "code": "from fqcn_converter import FQCNConverter\n\n# Initialize converter with default settings\nconverter = FQCNConverter()\n\n# Convert a playbook file\nresult = converter.convert_file(\"playbook.yml\")\n\nif result.success:\n    print(f\"\u2705 Successfully converted {result.changes_made} modules\")\nelse:\n    print(f\"\u274c Conversion failed: {result.errors}\")"
    },
    {
      "title": "Custom Configuration",
      "description": "Use custom FQCN mappings and configuration",
      "code": "from fqcn_converter import FQCNConverter\n\n# Custom mappings for specific modules\ncustom_mappings = {\n    \"my_module\": \"my.collection.my_module\",\n    \"custom_action\": \"company.internal.custom_action\"\n}\n\n# Initialize with custom configuration\nconverter = FQCNConverter(\n    config_path=\"custom_config.yml\",\n    custom_mappings=custom_mappings,\n    create_backups=True\n)\n\n# Convert with dry run to preview changes\nresult = converter.convert_file(\"playbook.yml\", dry_run=True)\nprint(f\"Would convert {result.changes_made} modules\")"
    },
    {
      "title": "Validation and Compliance",
      "description": "Validate FQCN compliance and get detailed reports",
      "code": "from fqcn_converter import ValidationEngine\n\n# Initialize validation engine\nvalidator = ValidationEngine()\n\n# Validate a file\nresult = validator.validate_conversion(\"playbook.yml\")\n\nprint(f\"Validation score: {result.score:.1%}\")\nprint(f\"Total modules: {result.total_modules}\")\nprint(f\"FQCN modules: {result.fqcn_modules}\")\n\nif not result.valid:\n    print(\"Issues found:\")\n    for issue in result.issues:\n        print(f\"  Line {issue.line_number}: {issue.message}\")\n        if issue.suggestion:\n            print(f\"    \ud83d\udca1 {issue.suggestion}\")"
    },
    {
      "title": "Batch Processing",
      "description": "Process multiple Ansible projects in parallel",
      "code": "from fqcn_converter import BatchProcessor\n\n# Initialize batch processor\nprocessor = BatchProcessor(max_workers=4)\n\n# Discover Ansible projects\nprojects = processor.discover_projects(\"/path/to/ansible/projects\")\nprint(f\"Found {len(projects)} Ansible projects\")\n\n# Process all projects\nresult = processor.process_projects(projects, dry_run=False)\n\nprint(f\"Processed {result.total_projects} projects\")\nprint(f\"Successful: {result.successful_conversions}\")\nprint(f\"Failed: {result.failed_conversions}\")\nprint(f\"Execution time: {result.execution_time:.2f}s\")"
    },
    {
      "title": "Content Processing",
      "description": "Process Ansible content directly from strings",
      "code": "from fqcn_converter import FQCNConverter\n\nconverter = FQCNConverter()\n\n# YAML content with short module names\nyaml_content = \"\"\"\n- name: Copy file\n  copy:\n    src: /tmp/source\n    dest: /tmp/dest\n\n- name: Install package\n  yum:\n    name: httpd\n    state: present\n\"\"\"\n\n# Convert content directly\nresult = converter.convert_content(yaml_content)\n\nif result.success:\n    print(\"Converted content:\")\n    print(result.converted_content)\nelse:\n    print(f\"Conversion failed: {result.errors}\")"
    }
  ],
  "type_hints": {
    "common_types": {
      "Union[str, Path]": "String or Path object",
      "Optional[str]": "String or None",
      "Dict[str, str]": "Dictionary with string keys and values",
      "List[str]": "List of strings",
      "List[ValidationIssue]": "List of validation issue objects"
    },
    "return_types": {
      "ConversionResult": "Object containing conversion operation results",
      "ValidationResult": "Object containing validation results and compliance score",
      "BatchResult": "Object containing batch processing results and statistics"
    }
  }
}